# 6_MySQL之索引原理与慢查询优化



## 一 介绍

**1、为何要有索引?**
　　　　一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。

**2、什么是索引？**
	1.索引在MySQL中也叫做“键”或者"key"（primary key，unique key，还有一个index key），**是存储引擎用于快速找到记录的一种数据结构**。

​	2.**索引对于良好的性能非常关键**，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要，减少io次数，加速查询。（其中primary key和unique key，除了有加速查询的效果之外，还有约束的效果，primary key 不为空且唯一，unique key 唯一，而index key只有加速查询的效果，没有约束效果）


tip;
	1.索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。
	2.强调：一旦为表创建了索引，以后的查询最好先查索引，再根据索引定位的结果去找数据

```mysql
					30

        10                          40

   5         15               35          66

1    6    11   19          21   39     55    100

```



**3、对索引存在的误解**
1、索引是应用程序设计和开发的一个重要方面。
2、若索引太多，应用程序的性能可能会受到影响。而索引太少，对查询性能又会产生影响

```mysql
# tip:
	一些开发人员总是在事后才想起添加索引----我一直认为，这源于一种错误的开发模式。如果知道数据的使用，从一开始就应该在需要处添加索引。开发人员往往对数据库的使用停留在应用的层面，比如编写SQL语句、存储过程之类，他们甚至可能不知道索引的存在，或认为事后让相关DBA加上即可。DBA往往不够了解业务的数据流，而添加索引需要通过监控大量的SQL语句进而从中找到问题，这个步骤所需的时间肯定是远大于初始添加索引所需的时间，并且可能会遗漏一部分的索引。当然索引也并不是越多越好，我曾经遇到过这样一个问题：某台MySQL服务器iostat显示磁盘使用率一直处于100%，经过分析后发现是由于开发人员添加了太多的索引，在删除一些不必要的索引之后，磁盘使用率马上下降为20%。可见索引的添加也是非常有技术含量的。
	
```





## 二 索引的原理

**1、索引原理**

```mysql
# 1.索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理

# 2.举例：
	# 书的目录占不占页数，这个页是不是也要存到硬盘里面，也占用硬盘空间。
	# 你在没有数据的情况下先建目录（索引）快，还是已经存在好多的数据了，然后再去建索引，哪个快 --- 没有数据的情况下先建索引 快


# 3.索引虽然会加快查询，但是会降低写入的效率
	# 但凡加入一些新的数据，都需要把书的目录（索引）重新做一个

# 4.索引的影响
	1、在表中有大量数据的前提下，创建索引速度会很慢
	2、在索引创建完毕后，对表的查询性能会发幅度提升，但是写性能会降低

# 本质：
	# 通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。

```



​		数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。

​		数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。

**2、磁盘IO与预读**

```mysql
# 磁盘IO和预读：
	# 磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分
	
	寻道时间
		# 磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；
	
	旋转延迟
		# 旋转延迟就是我们经常听说的磁盘转速，
		# 一个磁盘7200转/min，表示每分钟能转7200次，也就是说1秒钟能转120次.旋转延迟就是1/120/2 = 4.17ms，也就是半圈的时间（这里有两个时间：平均寻道时间，受限于目前的物理水平，大概是5ms的时间，找到磁道了
		# 还需要找到你数据存在的那个点，寻点时间，这寻点时间的一个平均值就是半圈的时间，这个半圈时间叫做平均延迟时间，那么平均延迟时间加上平均寻道时间就是你找到一个数据所消耗的平均时间z，大概9ms，其实机械硬盘慢主要是慢在这两个时间上了，当找到数据然后把数据拷贝到内存的时间是非常短暂的，和光速差不多了）；
		
		
	传输时间
		# 指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒。相对于前两个时间可以忽略不计。
		
		
# 总结：
	那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5 + 4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS（Million Instructions Per Second）的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的消耗的时间段下cpu可以执行约450万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难，所以我们要想办法降低IO次数。
	
	考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。
	
```







## 三 索引的数据结构

每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，**b+树**应运而生（B+树是通过二叉查找树，再由平衡二叉树，B树演化而来，

![](E:\learning_document\database_mysql\pictures\b+树.png)

### 1.结构说明

1、最上层是树根，中间的是树枝，最下面是叶子节点

2、浅蓝色的块我们称之为一个磁盘块或者叫做一个block块，这是操作系统一次IO往内存中读的内容。一个块对应四个扇区，  每个磁盘块包含几个**数据项**
		

​		3、深蓝色所示，**一个磁盘块里面包含多少数据**，一个深蓝色的块表示一个数据，其实不是数据
​		4、黄色所示，**指针** -- 
​				看最上面一个，p1表示比上面深蓝色的那个17小的数据的位置在哪，看它指针指向的左边那个块，里面的数据都比17小，p2指向的是比17大比35小的磁盘块），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。
​		5、**真实的数据**存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。

**总结**：非叶子节点只不存储真实的数据，只存储**指引搜索方向的数据项**，如17、35并不真实存在于数据表中。



### 2.b+树的查找过程

```mysql
# 如果要查找数据项29
	# 1. 将磁盘块1加载至内存中，此时即为发生了一次 IO 操作
	# 2.用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计
	# 3.通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，此时即为发生了第二次 IO 操作
	# 4.29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次 IO 操作
	# 总结： 共计发生了三次 IO 操作

3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。除了叶子节点，其他的树根啊树枝啊保存的就是数据的索引，他们是为你建立这种数据之间的关系而存在的。


```



### 3.b+树性质

```mysql
# 1.索引字段要尽量的小
		# IO次数取决于b+数的高度h或者说层级，这个高度或者层级就是你每次查询数据的IO次数
		# 假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m 数据项越大，h越小. m = 磁盘块的大小 / 数据项的大小.磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多,树的高度越低，这就是每个数据项需要索引字段尽可能的小，
		# 这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。
		# 思路：
		你的数据项越小，你的磁盘块盛放的数据量就越多了，所以如果一张表中有很多的字段，我们应该用什么字段来建立索引啊，如果你有id字段、name字段、描述信息字段等等的，你应该用哪个来建立索引啊，当然是id字段了，你想想对不对，因为id是个数字，占用空间最少啊。所用空间最少，磁盘块空间一定的情况下可存放的数据块越多，树的深度越小，IO 次数越少，所以加速查询速度。
		


# 2.索引的最左匹配特性
		#  从数据块的左边开始匹配，在匹配右边的
		#  当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的



```









## 四 聚集索引与辅助索引

```mysql
MyISAM 引擎在创建表时在硬盘上生成的文件
	.frm # 表结构
	.MYD # 数据文件
	.MYI # 索引文件 -- 索引也是存在硬盘上的

InnoDB引擎 是索引组织表
	.frm 
	.idb 数据、与索引索引
	
# 所以：
	InnoDB存储引擎的时候，每建一个表，就需要给一个主键，是因为这个主键是InnoDB存储引擎的.idb文件来组织存储数据的依据（方式），也就是说InnoDB存储引擎在存储数据的时候默认就按照索引的那种树形结构来帮你存。
	
# 聚集索引
	聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，

# 辅助索引
	
	
	
```



**数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index**

**相同点：**不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。

**不同点：叶子结点存放的是否是一整行的信息**



### 1、聚集索引

![](E:\learning_document\database_mysql\pictures\聚集索引.png)



```mysql
#InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。
	而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。


#如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。


# 如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。


# 由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。
	在多少情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。



# 聚集索引的好处
	# 1.它对主键的 排序查找 和 范围查找 速度非常快
		1.叶子节点的数据就是用户所要查询的数据。
		2.基于主键的聚集索引在创建完毕后就已经完成了排序，无需二次排序
		3.由于B+树索引是双向链表
select * from s1 order by id desc limit 10
# id 为主键的话的 InnoDB引擎，就是聚集索引

# 2.范围查询（range query）
		1.即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可
select * from s1 where id > 1 and id < 1000000; 
#没有聚集索引，预估需要检索的rows数如下，explain就是预估一下你的sql的执行效率	


# 案例：
		假设：id 是主键，name是辅助索引
		select name from tb1 where id=1;
		select age from tb1 where id=1;
		
		可以直接从叶子节点中直接拿到 name/age 的数据 -- 叶子节点中保存一条完整的行记录

```





### 2、辅助索引

```mysql
# 1.定义：
		# 除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引）（unique key啊、index key啊）
		# 与聚集索引的区别：辅助索引的叶子节点不包含行记录的全部数据。


# 叶子节点存放的内容：
	1.对应的那条数据的主键字段的值
	2.每个叶子节点中的索引行中包含一个书签（bookmark）
		ex: {'name字段'，name的值，主键id值}
		# InnoDB存储引擎去哪里可以找到与索引相对应的行数据
		假设：id 是主键，name是辅助索引
		select name from tb1 where name='xx';
		可以直接从叶子节点中拿到name数据 -- 也成为覆盖索引（的叶子节点就能找到你想找的数据可称为覆盖索引）
		select age from tb1 where age=24;
		通过辅助索引的叶子节点不能直接拿到age的值，而是需要叶子节点中的书签保存的主键id的值，在通过聚集索引得到完整的一条记录。
		
		
# 总结：
	由于InnoDB存储引擎是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键或者称为主键的值。如下图



```



![](E:\learning_document\database_mysql\pictures\辅助索引.png)





**辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引，但只能有一个聚集索引。**
**当通过辅助索引来寻找数据时**
	==1.InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得只想主键索引的主键==
	==2.通过主键索引来找到一个完整的行记录。==

**这种查找的效率也是非常高**

![](E:\learning_document\database_mysql\pictures\辅助索引_中文.png)





## 五 MySQL索引管理

```mysql
# 1.索引的功能：
        # 1.加速查询
        # 2.约束作用 --- primary key，unique，联合唯一也都是索引


	
# 2.mysql 常用索引

        # 1.普通索引INDEX：加速查找

        # 2.唯一索引：
            -主键索引 PRIMARY KEY：加速查找+约束（不为空、不能重复）
            -唯一索引 UNIQUE:加速查找+约束（不能重复）

        # 3.联合索引：
            -PRIMARY KEY(id,name):联合主键索引
            -UNIQUE(id,name):联合唯一索引
            -INDEX(id,name):联合普通索引


       # 除此之外还有全文索引，即FULLTEXT
            会员备注信息 ， 如果需要建索引的话，可以选择全文搜索。
            用于搜索很长一篇文章的时候，效果最好。
            用在比较短的文本，如果就一两行字的，普通的 INDEX 也可以。
            但其实对于全文搜索，我们并不会使用MySQL自带的该索引，而是会选择第三方软件如Sphinx，专门来做全文搜索。

	   # 其他的如空间索引SPATIAL，了解即可，几乎不用



# 3.索引操作：
		1.添加主键索引:
            way1: # 创建表的时候添加
                create table tb1 (
                    id int primary key,
                )
                # 或者
               create table tb1 (
                    id int,
                    primary key(id)
                )
            way2: # 表创建完了之后添加
                alter table tb1 add primary key(id);
                # 删除主键索引:
                alter table tb1 drop primary key(id);

          
         2.唯一索引:
			 # way1: # 创建表的时候添加
                  create table t1(
                    Id int unique,
                    )
                   # 或者 --- 记得要给索引起名字
                  create table t1(
                    Id int,
                    unique key uni_name (id)
                  )
              # way2: # 表创建完了之后添加 
                  alter table s1 add unique key  u_name(id);
                  删除:
                  alter table s1 drop index u_name;


         3.普通索引:
			 # way1: # 创建表的时候添加
                    Create table t1(
                    Id int,
                    Index index_name(id) # 这个要记住，之前没记住
                    )
              
			# way2: # 表创建完了之后添加
              	    Alter table s1 add index index_name(id);
              	    Create index index_name on s1(id);
                    # 删除:
                    Alter table s1 drop index u_name;
                    DROP INDEX 索引名 ON 表名字;



# 4.索引的两大类型hash与btree
	#我们可以在创建上述索引的时候，为其指定索引类型，分两类
    hash类型的索引：查询单条快，范围查询慢
    btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）

	#不同的存储引擎支持的索引类型也不一样
    InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
    MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
    Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；
    NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；
    Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；



# 5.创建/删除索引的标准语法

    #方法一：创建表时
          CREATE TABLE 表名 (
                    字段名1  数据类型 [完整性约束条件…],
                    字段名2  数据类型 [完整性约束条件…],
                    [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY
                    [索引名]  (字段名[(长度)]  [ASC |DESC]) 
                    );


    #方法二：CREATE在已存在的表上创建索引
            CREATE  [UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名 
                         ON 表名 (字段名[(长度)]  [ASC |DESC]) ;


    #方法三：ALTER TABLE在已存在的表上创建索引
            ALTER TABLE 表名 ADD  [UNIQUE | FULLTEXT | SPATIAL ] INDEX
                                 索引名 (字段名[(长度)]  [ASC |DESC]) ;

    #删除索引：DROP INDEX 索引名 ON 表名字;

```











## 六 测试索引

```mysql
#1. 一定是为搜索条件的字段创建索引，比如select * from s1 where id = 333;就需要为id加上索引

#2. 在表中已经有大量数据的情况下，建索引会很慢，且占用硬盘空间，建完后查询速度加快
    比如create index idx on s1(id);会扫描表中所有的数据，然后以id为数据项，创建索引结构，存放于硬盘的表中。
    建完以后，再查询就会很快了。

#3. 需要注意的是：innodb表的索引会存放于s1.ibd文件中，而myisam表的索引则会有单独的索引文件table1.MYI

    MyiSAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在innodb中，表数据文件本身就是按照B+Tree（BTree即Balance True）组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此innodb表数据文件本身就是主索引。
    因为inndob的数据文件要按照主键聚集，所以innodb要求表必须要有主键（Myisam可以没有），如果没有显式定义，则mysql系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则mysql会自动为innodb表生成一个隐含字段作为主键，这字段的长度为6个字节，类型为长整型.
```









## 七 正确使用索引

```mysql
# 一 索引未命中
	# 不是说我们创建了索引就一定会加快查询速度，
	# 我们在添加索引时，必须遵循以下问题 --- 索引未能命中的情况:
	
	1 范围问题，或者说条件不明确，条件中出现这些符号或关键字：>、>=、<、<=、!= 、between...and...、like、注意查询的时候以下情况：
        select count(*) from tb1 where id = 10000; # 明确条件，索引树可以快速找到

        select count(*) from tb1 where id > 10000;
        # 指定了一个范围，mysql会向着 100001， 100002 在搜索树中查找，假如范围很大，相当于全表扫描，效率很低


        # 范围很小，查询依旧很快，但是随着范围变大，查询速度成倍变慢
        select count(*) from tb1 where id > 1000 and id < 2000;
        select count(*) from tb1 where id between 1 and 3;


        # 很大的范围
        select count(*) from tb1 where id != 10000;
        select count(*) from tb1 where id between 1 and 110000;
	
	   # like, like匹配精准的值，查询速度快
	   select count(*) from tb1 where email like 'xxx';
	   select count(*) from tb1 where email like 'xxx%'; # % 处于末尾，速度依旧很快 --- 最左匹配的规则
	   select count(*) from tb1 where email like '%xxx';# % 处于开头，查询速度慢
	
    
    
	2 尽量选择区分度高的列作为索引。
		区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少。唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录
	   
	   # 对于区分度低的字段，无法找到大小关系，因为值都是相等的，毫无疑问，还想要用b+树存放这些等值的数据，只能增加树的高度，字段的区分度越低，则树的高度越高。极端的情况，索引字段的值都一样，那么b+树几乎成了一根棍

        # 结论：为区分度低的字段建立索引，索引树的高度会很高，带来的影响呢：
        --- name 数据均为 egon 的话
        # 1：如果条件是name='xxxx',那么肯定是可以第一时间判断出'xxxx'是不在索引树中的（因为树中所有的值均为'egon’,看第一条的时候就知道你不在索引树里面了），所以查询速度很快
        # 2：如果条件正好是name='egon',查询时，我们永远无法从树的某个位置得到一个明确的范围，只能往下找，往下找，往下找。。。这与全表扫描的IO次数没有多大区别，所以速度很慢



	3 = 和 in 可以乱序
        # 比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
	
	
	4 索引列不能参与计算 保持列“干净”
		# 比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)
	
	
	5 and/or --- 联合索引只支持 and, 不支持 or, 因为 and 相当于可以变换顺序
		    # and的工作原理
		    条件：
        		a = 10 and b = 'xxx' and c > 3 and d =4
    		索引：
        		制作联合索引(d,a,b,c)
        		
    		工作原理:  
    			#如果是你找的话，你会怎么找，是不是从左到右一个一个的比较啊，首先你不能确定a这个字段是不是有索引，即便是有索引，也不一定能确保命中索引了（所谓命中索引，就是应用上了索引），mysql不会这么笨的，看下面mysql是怎么找的：
    			
        	索引的本质原理就是先不断的把查找范围缩小下来，然后再进行处理，对于连续多个and：mysql会按照联合索引，从左到右的顺序找一个区分度高的索引字段(这样便可以快速锁定很小的范围)，加速查询，查询优化器可以将上述sql优化成， 
        	d =4 and a = 10 and b = 'xxx' and c > 3
        	即按照d—>a->b->c的顺序

			# or的工作原理 -- 使用or连接各个查询条件无法命中索引
			条件：
        		a = 10 or b = 'xxx' or c > 3 or d =4
    		索引：
        		制作联合索引(d,a,b,c) 
        
    		工作原理:
        		只要一个匹配成功就行，所以对于连续多个or：mysql会按照条件的顺序，从左到右依次判断，即a->b->c->d
	
	
	
	
	6 最左前缀匹配原则（详见第八小节）
		# 对于组合索引mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配(指的是范围大了，有索引速度也慢)
		比如a = 1 and b = 2 and c > 3 and d = 4
		联合索引(a, b, c, d)， 是用不到 索引 d 的，
		联合索引(a,b,d,c), 则都可以用到
	
	
	
	7 其他情况 --- 不能命中索引的
            - 使用函数 
            	select * from tb1 where reverse(email) = 'egon';

        	- 类型不一致
                如果列是字符串类型，传入条件是必须用引号引起来，不然...
                select * from tb1 where email = 999;

        	#排序条件为索引，则select字段必须也是索引字段，否则无法命中
        	- order by
                select name from s1 order by email desc;
                当根据索引排序时候，select查询的字段如果不是索引，则速度仍然很慢
                select email from s1 order by email desc;
                特别的：如果对主键排序，则还是速度很快：
                    select * from tb1 order by nid desc;

        	- 组合索引最左前缀
            	如果组合索引为：(name,email)
            	name and email       -- 命中索引
            	name                 -- 命中索引
            	email                -- 未命中索引


        	- count(1)或count(列)代替count(*)在mysql中没有差别了

        	- create index xxxx  on tb(title(19)) #text类型，必须制定长度







# 二 其他注意事项

    - 避免使用select *
    - count(1)或count(列) 代替 count(*)
    - 创建表时尽量时 char 代替 varchar
    - 表的字段顺序固定长度的字段优先
    - 组合索引代替多个单列索引（经常使用多个条件查询时）
    - 尽量使用短索引
    - 使用连接（JOIN）来代替子查询(Sub-Queries)
    - 连表时注意条件类型需一致
    - 索引散列值（重复少）不适合建索引，例：性别不适合
    
    
```













## 八 联合索引与覆盖索引

### 1.联合索引

![](E:\learning_document\database_mysql\pictures\联合索引.png)

```mysql
# 定义：
	联合索引时指对表上的多个列合起来做一个索引，避免查询的时候，where后面的条件字段一直变化，你就想给每个字段加索引的尴尬问题。

# 本质：是一颗 b+ 树

create table t(
    a int,
    b int,
    primary key(a),
    key idx_a_b(a,b)
    );
    

# 原理：
联合索引的B+树 与 单个键的B+树并没有什么不同，键值都是排序的，通过叶子结点可以逻辑上顺序地读出所有数据，就上面的例子来说，即（1,1），（1,2），（2,1），（2,4），（3,1），（3,2），数据按（a,b）的顺序进行了存放。

	所以 以下两个查询语句均可使用 联合索引 (a, b) -- 组合索引最左前缀
	select * from table where a=xxx and b=xxx
	select * from table where a=xxx 
	
	select * from table where b=xxx # 不可以使用联合索引 (a, b)
	
```



**注意建立联合索引的一个原则** --- **索引的最左匹配原则**
			==1.将区分度高的放在最左边，依次排下来，==
			==2.范围查询的条件尽可能的往后边放。==

**联合索引的第二个好处是在第一个键相同的情况下，已经对第二个键进行了排序处理**





### 2.覆盖索引

```mysql
# 定义：
	InnoDB存储引擎支持覆盖索引（covering index，或称索引覆盖），即从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录。--- 辅助索引中叶子节点中直接获取到数据
	
	
# 优点：
	辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作


# 注意：
	覆盖索引技术最早是在InnoDB Plugin中完成并实现，这意味着对于InnoDB版本小于1.0的，或者MySQL数据库版本为5.0以下的，InnoDB存储引擎不支持覆盖索引特性


explain select name from s1 where id=1000; #没有任何索引
create index idx_id on s1(id); #创建索引
explain select name from s1 where id=1000; #命中辅助索引，但是未覆盖索引，还需要从聚集索引中查找name
explain select id from s1 where id=1000; #在辅助索引中就找到了全部信息，Using index 代表 覆盖索引


# 特殊情况：
	# 联合索引userid_2（userid,buy_date）,一般情况，我们按照buy_date是无法使用该索引的，但特殊情况下：查询语句是统计操作，且是覆盖索引，则按照buy_date当做查询条件时，也可以使用该联合索引， 这种情况是会命中索引的
explain select count(*) from buy_log where buy_date >= '2011-01-01' and buy_date < '2011-02-01';
	

```









## 九 查询优化神器-explain

**关于explain，如果大家有兴趣，可以看看这篇博客，他总结的挺好的：http://www.cnblogs.com/yycc/p/7338894.html**

```mysql
# 执行计划：让mysql预估执行操作(一般正确)
    all < index < range < index_merge < ref_or_null < ref < eq_ref < system/const
    id,email
    
    慢：
        select * from userinfo3 where name='alex'
        
        explain select * from userinfo3 where name='alex'
        type: ALL(全表扫描)
            select * from userinfo3 limit 1;
    快：
        select * from userinfo3 where email='alex'
        type: const(走索引)
        

```





## 十 慢查询优化的基本步骤

```mysql
# 0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE

# 1.where条件单表查，锁定最小返回记录表。
	这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高

# 2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）

# 3.order by limit 形式的sql语句让排序的表优先查

# 4.了解业务方使用场景

# 5.加索引时参照建索引的几大原则

# 6.观察结果，不符合预期继续从0分析


```



```mysql
MySQL日志管理
========================================================
错误日志: 记录 MySQL 服务器启动、关闭及运行错误等信息
二进制日志: 又称binlog日志，以二进制文件的方式记录数据库中除 SELECT 以外的操作
查询日志: 记录查询的信息
慢查询日志: 记录执行时间超过指定时间的操作
中继日志： 备库将主库的二进制日志复制到自己的中继日志中，从而在本地进行重放
通用日志： 审计哪个账号、在哪个时段、做了哪些事件
事务日志或称redo日志： 记录Innodb事务相关的如事务执行时间、检查点等
========================================================
一、bin-log
1. 启用
# vim /etc/my.cnf
[mysqld]
log-bin[=dir\[filename]]
# service mysqld restart
2. 暂停
//仅当前会话
SET SQL_LOG_BIN=0;
SET SQL_LOG_BIN=1;
3. 查看
查看全部：
# mysqlbinlog mysql.000002
按时间：
# mysqlbinlog mysql.000002 --start-datetime="2012-12-05 10:02:56"
# mysqlbinlog mysql.000002 --stop-datetime="2012-12-05 11:02:54"
# mysqlbinlog mysql.000002 --start-datetime="2012-12-05 10:02:56" --stop-datetime="2012-12-05 11:02:54" 

按字节数：
# mysqlbinlog mysql.000002 --start-position=260
# mysqlbinlog mysql.000002 --stop-position=260
# mysqlbinlog mysql.000002 --start-position=260 --stop-position=930
4. 截断bin-log（产生新的bin-log文件）
a. 重启mysql服务器
b. # mysql -uroot -p123 -e 'flush logs'
5. 删除bin-log文件
# mysql -uroot -p123 -e 'reset master' 


二、查询日志
启用通用查询日志
# vim /etc/my.cnf
[mysqld]
log[=dir\[filename]]
# service mysqld restart

三、慢查询日志
启用慢查询日志
# vim /etc/my.cnf
[mysqld]
log-slow-queries[=dir\[filename]]
long_query_time=n
# service mysqld restart
MySQL 5.6:
slow-query-log=1
slow-query-log-file=slow.log
long_query_time=3
查看慢查询日志
测试:BENCHMARK(count,expr)
SELECT BENCHMARK(50000000,2*3);
```





## 十一 慢日志管理

```mysql
慢日志
            - 执行时间 > 10
            - 未命中索引
            - 日志文件路径
            
        配置：
            - 内存
                show variables like '%query%';
                show variables like '%queries%';
                set global 变量名 = 值
            - 配置文件
                mysqld --defaults-file='E:\wupeiqi\mysql-5.7.16-winx64\mysql-5.7.16-winx64\my-default.ini'
                
                my.conf内容：
                    slow_query_log = ON
                    slow_query_log_file = D:/....
                    
                注意：修改配置文件之后，需要重启服务


```

