# 6_MySQL之索引原理与慢查询优化



## 一 介绍

**1、为何要有索引?**
　　　　一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。

**2、什么是索引？**
	1.索引在MySQL中也叫做“键”或者"key"（primary key，unique key，还有一个index key），**是存储引擎用于快速找到记录的一种数据结构**。

​	2.**索引对于良好的性能非常关键**，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要，减少io次数，加速查询。（其中primary key和unique key，除了有加速查询的效果之外，还有约束的效果，primary key 不为空且唯一，unique key 唯一，而index key只有加速查询的效果，没有约束效果）


tip;
	1.索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。
	2.强调：一旦为表创建了索引，以后的查询最好先查索引，再根据索引定位的结果去找数据

```mysql
					30

        10                          40

   5         15               35          66

1    6    11   19          21   39     55    100

```



**3、对索引存在的误解**
1、索引是应用程序设计和开发的一个重要方面。
2、若索引太多，应用程序的性能可能会受到影响。而索引太少，对查询性能又会产生影响

```mysql
# tip:
	一些开发人员总是在事后才想起添加索引----我一直认为，这源于一种错误的开发模式。如果知道数据的使用，从一开始就应该在需要处添加索引。开发人员往往对数据库的使用停留在应用的层面，比如编写SQL语句、存储过程之类，他们甚至可能不知道索引的存在，或认为事后让相关DBA加上即可。DBA往往不够了解业务的数据流，而添加索引需要通过监控大量的SQL语句进而从中找到问题，这个步骤所需的时间肯定是远大于初始添加索引所需的时间，并且可能会遗漏一部分的索引。当然索引也并不是越多越好，我曾经遇到过这样一个问题：某台MySQL服务器iostat显示磁盘使用率一直处于100%，经过分析后发现是由于开发人员添加了太多的索引，在删除一些不必要的索引之后，磁盘使用率马上下降为20%。可见索引的添加也是非常有技术含量的。
	
```





## 二 索引的原理

**1、索引原理**

```mysql
# 1.索引的目的在于提高查询效率，与我们查阅图书所用的目录是一个道理

# 2.举例：
	# 书的目录占不占页数，这个页是不是也要存到硬盘里面，也占用硬盘空间。
	# 你在没有数据的情况下先建目录（索引）快，还是已经存在好多的数据了，然后再去建索引，哪个快 --- 没有数据的情况下先建索引 快


# 3.索引虽然会加快查询，但是会降低写入的效率
	# 但凡加入一些新的数据，都需要把书的目录（索引）重新做一个

# 4.索引的影响
	1、在表中有大量数据的前提下，创建索引速度会很慢
	2、在索引创建完毕后，对表的查询性能会发幅度提升，但是写性能会降低

# 本质：
	# 通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是说，有了这种索引机制，我们可以总是用同一种查找方式来锁定数据。

```



​		数据库也是一样，但显然要复杂的多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。

​		数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的。而数据库实现比较复杂，一方面数据是保存在磁盘上的，另外一方面为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。

**2、磁盘IO与预读**

```mysql
# 磁盘IO和预读：
	# 磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分
	
	寻道时间
		# 磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；
	
	旋转延迟
		# 旋转延迟就是我们经常听说的磁盘转速，
		# 一个磁盘7200转/min，表示每分钟能转7200次，也就是说1秒钟能转120次.旋转延迟就是1/120/2 = 4.17ms，也就是半圈的时间（这里有两个时间：平均寻道时间，受限于目前的物理水平，大概是5ms的时间，找到磁道了
		# 还需要找到你数据存在的那个点，寻点时间，这寻点时间的一个平均值就是半圈的时间，这个半圈时间叫做平均延迟时间，那么平均延迟时间加上平均寻道时间就是你找到一个数据所消耗的平均时间z，大概9ms，其实机械硬盘慢主要是慢在这两个时间上了，当找到数据然后把数据拷贝到内存的时间是非常短暂的，和光速差不多了）；
		
		
	传输时间
		# 指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒。相对于前两个时间可以忽略不计。
		
		
# 总结：
	那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5 + 4.17 = 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS（Million Instructions Per Second）的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的消耗的时间段下cpu可以执行约450万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难，所以我们要想办法降低IO次数。
	
	考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。
	
```







## 三 索引的数据结构

每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，**b+树**应运而生（B+树是通过二叉查找树，再由平衡二叉树，B树演化而来，

![](E:\learning_document\database_mysql\pictures\b+树.png)

### 1.结构说明

1、最上层是树根，中间的是树枝，最下面是叶子节点

2、浅蓝色的块我们称之为一个磁盘块或者叫做一个block块，这是操作系统一次IO往内存中读的内容。一个块对应四个扇区，  每个磁盘块包含几个**数据项**
		

​		3、深蓝色所示，**一个磁盘块里面包含多少数据**，一个深蓝色的块表示一个数据，其实不是数据
​		4、黄色所示，**指针** -- 
​				看最上面一个，p1表示比上面深蓝色的那个17小的数据的位置在哪，看它指针指向的左边那个块，里面的数据都比17小，p2指向的是比17大比35小的磁盘块），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。
​		5、**真实的数据**存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。

**总结**：非叶子节点只不存储真实的数据，只存储**指引搜索方向的数据项**，如17、35并不真实存在于数据表中。



### 2.b+树的查找过程

```mysql
# 如果要查找数据项29
	# 1. 将磁盘块1加载至内存中，此时即为发生了一次 IO 操作
	# 2.用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计
	# 3.通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，此时即为发生了第二次 IO 操作
	# 4.29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次 IO 操作
	# 总结： 共计发生了三次 IO 操作

3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。除了叶子节点，其他的树根啊树枝啊保存的就是数据的索引，他们是为你建立这种数据之间的关系而存在的。


```



### 3.b+树性质

```mysql
# 1.索引字段要尽量的小
		# IO次数取决于b+数的高度h或者说层级，这个高度或者层级就是你每次查询数据的IO次数
		# 假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m 数据项越大，h越小. m = 磁盘块的大小 / 数据项的大小.磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多,树的高度越低，这就是每个数据项需要索引字段尽可能的小，
		# 这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。
		# 思路：
		你的数据项越小，你的磁盘块盛放的数据量就越多了，所以如果一张表中有很多的字段，我们应该用什么字段来建立索引啊，如果你有id字段、name字段、描述信息字段等等的，你应该用哪个来建立索引啊，当然是id字段了，你想想对不对，因为id是个数字，占用空间最少啊。所用空间最少，磁盘块空间一定的情况下可存放的数据块越多，树的深度越小，IO 次数越少，所以加速查询速度。
		


# 2.索引的最左匹配特性
		#  从数据块的左边开始匹配，在匹配右边的
		#  当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的



```









## 四 聚集索引与辅助索引

```mysql
MyISAM 引擎在创建表时在硬盘上生成的文件
	.frm # 表结构
	.MYD # 数据文件
	.MYI # 索引文件 -- 索引也是存在硬盘上的

InnoDB引擎 是索引组织表
	.frm 
	.idb 数据、与索引索引
	
# 所以：
	InnoDB存储引擎的时候，每建一个表，就需要给一个主键，是因为这个主键是InnoDB存储引擎的.idb文件来组织存储数据的依据（方式），也就是说InnoDB存储引擎在存储数据的时候默认就按照索引的那种树形结构来帮你存。
	
# 聚集索引
	聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，

# 辅助索引
	
	
	
```



**数据库中的B+树索引可以分为聚集索引（clustered index）和辅助索引（secondary index**

**相同点：**不管是聚集索引还是辅助索引，其内部都是B+树的形式，即高度是平衡的，叶子结点存放着所有的数据。

**不同点：叶子结点存放的是否是一整行的信息**



### 1、聚集索引

![](E:\learning_document\database_mysql\pictures\聚集索引.png)



```mysql
#InnoDB存储引擎表示索引组织表，即表中数据按照主键顺序存放。
	而聚集索引（clustered index）就是按照每张表的主键构造一棵B+树，同时叶子结点存放的即为整张表的行记录数据，也将聚集索引的叶子结点称为数据页。聚集索引的这个特性决定了索引组织表中数据也是索引的一部分。同B+树数据结构一样，每个数据页都通过一个双向链表来进行链接。


#如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。


# 如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。


# 由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。
	在多少情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据。此外由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对范围值得查询。



# 聚集索引的好处
	# 1.它对主键的 排序查找 和 范围查找 速度非常快
		1.叶子节点的数据就是用户所要查询的数据。
		2.基于主键的聚集索引在创建完毕后就已经完成了排序，无需二次排序
		3.由于B+树索引是双向链表
select * from s1 order by id desc limit 10
# id 为主键的话的 InnoDB引擎，就是聚集索引

# 2.范围查询（range query）
		1.即如果要查找主键某一范围内的数据，通过叶子节点的上层中间节点就可以得到页的范围，之后直接读取数据页即可
select * from s1 where id > 1 and id < 1000000; 
#没有聚集索引，预估需要检索的rows数如下，explain就是预估一下你的sql的执行效率	


# 案例：
		假设：id 是主键，name是辅助索引
		select name from tb1 where id=1;
		select age from tb1 where id=1;
		
		可以直接从叶子节点中直接拿到 name/age 的数据 -- 叶子节点中保存一条完整的行记录

```





### 2、辅助索引

```mysql
# 1.定义：
		# 除了聚集索引外其他索引都是辅助索引（Secondary Index，也称为非聚集索引）（unique key啊、index key啊）
		# 与聚集索引的区别：辅助索引的叶子节点不包含行记录的全部数据。


# 叶子节点存放的内容：
	1.对应的那条数据的主键字段的值
	2.每个叶子节点中的索引行中包含一个书签（bookmark）
		ex: {'name字段'，name的值，主键id值}
		# InnoDB存储引擎去哪里可以找到与索引相对应的行数据
		假设：id 是主键，name是辅助索引
		select name from tb1 where name='xx';
		可以直接从叶子节点中拿到name数据 -- 也成为覆盖索引（的叶子节点就能找到你想找的数据可称为覆盖索引）
		select age from tb1 where age=24;
		通过辅助索引的叶子节点不能直接拿到age的值，而是需要叶子节点中的书签保存的主键id的值，在通过聚集索引得到完整的一条记录。
		
		
# 总结：
	由于InnoDB存储引擎是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的聚集索引键或者称为主键的值。如下图



```



![](E:\learning_document\database_mysql\pictures\辅助索引.png)





**辅助索引的存在并不影响数据在聚集索引中的组织，因此每张表上可以有多个辅助索引，但只能有一个聚集索引。**
**当通过辅助索引来寻找数据时**
	==1.InnoDB存储引擎会遍历辅助索引并通过叶子级别的指针获得只想主键索引的主键==
	==2.通过主键索引来找到一个完整的行记录。==

**这种查找的效率也是非常高**

![](E:\learning_document\database_mysql\pictures\辅助索引_中文.png)





## 五 MySQL索引管理













## 六 测试索引













## 七 正确使用索引











## 八 联合索引与覆盖索引







## 九 查询优化神器-explain





## 十 慢查询优化的基本步骤





## 十一 慢日志管理